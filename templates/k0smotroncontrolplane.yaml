{{/*
K0smotronControlPlane resource - Hosted control plane configuration
This resource defines a control plane that runs as pods in the management cluster
instead of on dedicated infrastructure machines. It includes:
- k0s version and replica configuration
- Optional ingress configuration for hostname-based access (apiHost, konnectivityHost)
- Embedded k0s configuration with Hetzner Cloud Controller Manager and CSI driver
- Service configuration for control plane endpoint exposure
*/}}
{{- $global := .Values.global | default dict }}
apiVersion: controlplane.cluster.x-k8s.io/v1beta1
kind: K0smotronControlPlane
metadata:
  name: {{ include "k0smotroncontrolplane.name" . }}
spec:
  version: {{ .Values.k0s.version }}
  replicas: {{ .Values.controlPlane.replicas | default 1 }}
  # External address configuration for k0smotron bootstrap process
  # Use internal service address to avoid ingress/load balancer issues during bootstrap
  externalAddress: "kmc-{{ include "cluster.name" . }}.{{ .Release.Namespace }}.svc.cluster.local"
  # Ingress configuration enables hostname-based access to the control plane
  # Required for worker nodes to connect to control plane via management cluster ingress
  # Traffic flows: Worker Nodes -> Management LB -> HAProxy Ingress (SSL passthrough) -> Control Plane Pods
  ingress:
    enabled: true
    className: haproxy  # Use HAProxy ingress class for SSL passthrough support
    annotations:
      haproxy.org/ssl-passthrough: "true"  # Enable SSL passthrough from management LB to control plane pods
    {{- if .Values.controlPlane.ingress.apiHost }}
    apiHost: {{ .Values.controlPlane.ingress.apiHost }}  # Hostname for Kubernetes API access (e.g., api.cluster01.example.com)
    {{- end }}
    {{- if .Values.controlPlane.ingress.konnectivityHost }}
    konnectivityHost: {{ .Values.controlPlane.ingress.konnectivityHost }}  # Hostname for konnectivity server (e.g., konnectivity.cluster01.example.com)
    {{- end }}
  # Service configuration for control plane endpoint exposure
  # ClusterIP is used for ingress-based access (k0smotron will handle internal routing)
  service:
    type: {{ .Values.controlPlane.service.type | default "ClusterIP" }}  # ClusterIP for ingress-based access
    {{- if eq (.Values.controlPlane.service.type | default "ClusterIP") "NodePort" }}
    apiNodePort: {{ .Values.controlPlane.service.apiNodePort | default 30443 }}
    konnectivityNodePort: {{ .Values.controlPlane.service.konnectivityNodePort | default 30132 }}
    {{- end }}
  k0sConfig:
    apiVersion: k0s.k0sproject.io/v1beta1
    kind: ClusterConfig
    metadata:
      name: k0s
    spec:
      api:
        sans:
          - {{ .Values.controlPlane.ingress.apiHost }}
          - {{ .Values.controlPlane.ingress.konnectivityHost }}
          # Add management cluster node IPs for NodePort access
          {{- if eq (.Values.controlPlane.service.type | default "NodePort") "NodePort" }}
          - "k0rdent-cluster"  # Management cluster node hostname
          {{- end }}
          # Add internal service hostname for k0smotron controller validation
          - "kmc-{{ include "cluster.name" . }}.{{ .Release.Namespace }}.svc.cluster.local"
        extraArgs:
          anonymous-auth: "true"
          {{- with .Values.k0s.api.extraArgs }}
          {{- toYaml . | nindent 10 }}
          {{- end }}
      {{- with .Values.k0s.network }}
      network: {{ toYaml . | nindent 8 }}
      {{- end }}
      # Configure k0s to use external cloud provider (Hetzner Cloud Controller Manager)
      # This prevents k0s from trying to manage node addresses internally
      extensions:
        helm:
          repositories: []
          charts: []
      telemetry:
        enabled: false
